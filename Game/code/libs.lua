---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chex.
--- DateTime: 1/28/2022 7:56 PM
---


--- global game tables
core = {} -- basic libraries and functions (core.draw, etc)
g = {}    -- holds all GLOBAL data (independent of game state)
game = {} -- holds all functions/vars relative to the game
menu = {} -- holds all functions/vars relative to the menu

--- love2d constants
lfs = love.filesystem
lg = love.graphics
ls = love.system
lw = love.window
lk = love.keyboard
le = love.event


------------------------ 'core' variables
-- determine the window size
core.sWidth, core.sHeight = lg.getDimensions()

-- determine the "bump" values
core.bumpX = (core.sWidth-800)/2
core.bumpY = (core.sHeight-600)/2

core.keyMaps = {
    left = "leftR",
    right = "rightR",
    up = "upR",
    down = "downR",

    a = "leftL",
    d = "rightL",
    w = "upL",
    s = "downL",

    ["return"] = "confirm",
    escape = "cancel"
}
------------------------ 'g' variables

-- stores all images used in the game
g.img = {}
g.imagePointers = {
    desktop = "desktop.png",
    playAreaBg = "playAreaBg.png",
    playAreaWindow = "playAreaWindow.png",
    playAreaForeground = "playAreaForeground.png",
    progressWindow = "progressWindow.png",
    menuTask = "task.png",
    menuTaskSelected = "taskSelected.png",
    menuTaskContext = "taskContext.png",
    menuTaskContextSelected = "taskContextSelected.png",
    menuStart = "start.png",
    menuStartSelected = "startSelected.png",
    menuStartContext = "startContext.png",
    menuStartContextSelected = "startContextSelected.png",
    taskbar = "taskbar.png",
    terminal = "terminal.png",
    hitZone = "hitZone.png",
    hitZoneForeground = "hitZoneForeground.png",
    beatInnerX = "beatInnerX.png",
    beatOuterX = "beatOuterX.png",
    beatInnerY = "beatInnerY.png",
    beatOuterY = "beatOuterY.png",
    progressGraphic = "progressGraphic.png",
    nice = "nice.png",
    perfect = "perfect.png",
    time = "time.png",
}

g.snd = {}
g.soundPointers = {
    hitLeft = "hitLeft.ogg",
    hitRight = "hitRight.ogg",
    menuNavX = "menuNavX.ogg",
    menuNavY = "menuNavY.ogg",
    tada = "tada.mp3",
    chord = "chord.mp3"
}

g.sfxVolume = 1
g.songVolume = 0.5
------------------------ 'game' variables

game.fieldOffset = {x = 50, y = 40}

game.beats = {}

game.songSlowdown = (140/120)

game.mapDirectory = "assets/maps/"
game.currentSong = false
game.currentMap = {}

game.approachRate = 0.65
game.niceThreshold = 0.26/2
game.perfectThreshold = 0.13/2


--- beatmap structure:
--- {
---     {
---         timestamp,
---         "U2"
---     }
--- }
game.beatmapData = {
    {5,
    "L2"},

    {5.5,
     "R2"},
    {5.75,
     "U2"},
    {6,
     "R2"},
    {6.25,
     "U2"},
    {6.5,
     "L2"},

    {7,
     "R2"},
    {7.25,
     "U2"},
    {7.5,
     "R2"},
    {7.75,
     "U2"},
    {8,
     "L2"},

    {8.5,
     "U1"},
    {8.5,
     "D2"},

    {9,
     "L2"},

    {9.5,
     "R2"},
    {9.75,
     "U2"},
    {10,
     "R2"},
    {10.25,
     "U2"},
    {10.5,
     "L2"},

    {11,
     "R2"},
    {11.25,
     "U2"},
    {11.5,
     "R2"},
    {11.75,
     "U2"},
    {12,
     "L2"},

    {12.5,
     "L2"},
    {12.5,
     "R2"},
    {12.5,
     "U1"},

    {13,
     "D2"},

    {13.5,
     "R2"},
    {13.75,
     "U2"},
    {14,
     "R2"},
    {14.25,
     "U2"},
    {14.5,
     "L2"},

    {15,
     "R2"},
    {15.25,
     "U2"},
    {15.5,
     "R2"},
    {15.75,
     "U2"},
    {16,
     "L2"},

    {16.5,
     "L2"},
    {16.5,
     "R2"},
    {16.5,
     "U2"},
    {16.5,
     "L1"},
    {16.5,
     "R1"},
    {16.5,
     "U1"},

    {17,
     "D2"},

    {17.5,
     "R2"},
    {17.75,
     "U2"},
    {18,
     "R2"},
    {18.25,
     "U2"},
    {18.5,
     "L2"},

    {19,
     "R2"},
    {19.25,
     "U2"},
    {19.5,
     "R2"},
    {19.75,
     "U2"},
    {20,
     "L2"},

    {21,
     "D2"},

    {21.5,
     "R2"},
    {21.75,
     "U2"},
    {22,
     "R2"},
    {22.25,
     "U2"},
    {22.5,
     "L2"},
    {22.5,
     "D1"},


    {23,
     "R2"},
    {23.25,
     "U2"},
    {23.5,
     "R2"},
    {23.75,
     "U2"},
    {24,
     "L2"},
    {24,
     "D1"},

    {24.5,
     "L2"},
    {24.5,
     "D1"},

    {25,
     "L2"},
    {25,
     "D1"},

    {25.5,
     "R2"},
    {25.75,
     "U2"},
    {26,
     "R2"},
    {26.25,
     "U2"},
    {26.5,
     "L2"},
    {26.5,
     "D1"},


    {27,
     "R2"},
    {27.25,
     "U2"},
    {27.5,
     "R2"},
    {27.75,
     "U2"},
    {28,
     "L2"},
    {28,
     "D1", 2, 0.5},

    {29,
     "D2"},

    {29.5,
     "R2"},
    {29.75,
     "D2"},
    {30,
     "R2"},
    {30.25,
     "D2"},
    {30.5,
     "L2"},
    {30.5,
     "R1"},


    {31,
     "R2"},
    {31.25,
     "D2"},
    {31.5,
     "R2"},
    {31.75,
     "D2"},
    {32,
     "L2"},
    {32,
     "R1"},
    {32.5,
     "L2"},
    {32.5,
     "R1"},

    {33,
     "L2"},
    {33,
     "R1"},

    {33.5,
     "R2"},
    {33.75,
     "D2"},
    {34,
     "R2"},
    {34.25,
     "D2"},
    {34.5,
     "L2"},
    {34.5,
     "R1"},


    {35,
     "R2"},
    {35.25,
     "D2"},
    {35.5,
     "R2"},
    {35.75,
     "D2"},
    {36,
     "L2"},
    {36,
     "R1", 1, 0.5},

    -- bridge
    {37,
     "R2", 3, 2},

    {37.5,
    "D1", 2, .5},

    {39.5,
     "D1", 2, .5},

    {41.5,
     "U1", 2, .5},

    {43.5,
     "U1", 2, .5},

    {45,
     "L2"},

    {45.5,
     "U2"},
    {45.75,
     "R2"},
    {46,
     "D2"},
    {46.25,
     "L2"},
    {46.5,
     "U2"},

    {47,
     "L2"},
    {47.25,
     "D2"},
    {47.5,
     "R2"},
    {47.75,
     "U2"},
    {48,
     "L2"},

    {48.5,
     "L2"},

    {49,
     "L1"},

    {49.5,
     "U1"},
    {49.75,
     "R1"},
    {50,
     "D1"},
    {50.25,
     "L1"},
    {50.5,
     "U1"},

    {51,
     "L1"},
    {51.25,
     "D1"},
    {51.5,
     "R1"},
    {51.75,
     "U1"},
    {52,
     "L1"},

    {52.5,
     "L1"},

    {53,
     "R1", 3, 2},

    {53.5,
     "U2", 2, .5},

    {55.5,
     "U2", 2, .5},

    {57.5,
     "D2", 2, .5},

    {59.5,
     "D2", 2, .5},

    {61,
     "R1"},

    {61.5,
     "U1"},
    {61.75,
     "L1"},
    {62,
     "D1"},
    {62.25,
     "R1"},
    {62.5,
     "U1"},

    {63,
     "R1"},
    {63.25,
     "D1"},
    {63.5,
     "L1"},
    {63.75,
     "U1"},
    {64,
     "R1"},

    {64.5,
     "R1"},

    {65,
     "R2"},

    {65.5,
     "U2"},
    {65.75,
     "L2"},
    {66,
     "D2"},
    {66.25,
     "R2"},
    {66.5,
     "U2"},

    {67,
     "R2"},
    {67.25,
     "D2"},
    {67.5,
     "L2"},
    {67.75,
     "U2"},
    {68,
     "R2"},

    {68.5,
     "R2"},
}

--[[
    {
        2.50,
        "R2",
        4,
        .5
    },
]]

------------------------ 'menu' variables

menu.currentX = 1
menu.currentY = 1
menu.taskList = {
    start = { "exit" },
    play = { "jazzJackrabbit" },
    settings = { "song volume", "sfx volume" },
    credits = { "code", "graphics", "songs", "sfx" }
}
menu.taskListKeys = {
    "start", "play", "settings", "credits"
}

menu.taskOffsetX = {
    6, 77, 212, 348
}


---------------------------------------------------------------------
-------------------------CORE FUNCTIONS------------------------------

function core.playSound(audio)
    audio:stop()
    audio:setVolume(g.sfxVolume)
    audio:play()
end

function core.checkInput(key)
    local input = core.keyMaps[key] and core.keyMaps[key] or "unmapped"

    if input == "unmapped" then return end -- fuck it

    if game_state == "InGame" then

        print(input)

        local particleColor
        if string.sub(input, #input, #input) == "R" then
            particleColor = {.2,.25,1}
            core.playSound(g.snd.hitLeft)
        else
            particleColor = {1,.2,.25}
            core.playSound(g.snd.hitLeft)
        end

        if input == "leftL" or input == "leftR" then
            particle.create({
                img = g.img.beatInnerX,
                position = {core.bumpX + game.fieldOffset.x + 150, core.bumpY + game.fieldOffset.y + 150},
                velocity = {-.35,0},
                scale = {150/g.img.beatInnerX:getWidth(), 200/g.img.beatInnerX:getHeight()},
                lifetime = .25,
                color = particleColor,
                opacity = 1,
                opacityDelta = -0.05
            })
        elseif input == "rightL" or input == "rightR" then
            particle.create({
                img = g.img.beatInnerX,
                position = {core.bumpX + game.fieldOffset.x + 335, core.bumpY + game.fieldOffset.y + 150},
                velocity = {.25,0},
                scale = {150/g.img.beatInnerX:getWidth(), 200/g.img.beatInnerX:getHeight()},
                lifetime = .25,
                color = particleColor,
                opacity = 1,
                opacityDelta = -0.05
            })
        elseif input == "upL" or input == "upR" then
            particle.create({
                img = g.img.beatInnerY,
                position = {core.bumpX + game.fieldOffset.x + 150, core.bumpY + game.fieldOffset.y + 150},
                velocity = {0,-.25},
                scale = {200/g.img.beatInnerY:getWidth(), 150/g.img.beatInnerY:getHeight()},
                lifetime = .25,
                color = particleColor,
                opacity = 1,
                opacityDelta = -0.05
            })
        elseif input == "downL" or input == "downR" then
            particle.create({
                img = g.img.beatInnerY,
                position = {core.bumpX + game.fieldOffset.x + 150, core.bumpY + game.fieldOffset.y + 335},
                velocity = {0,.25},
                scale = {200/g.img.beatInnerY:getWidth(), 150/g.img.beatInnerY:getHeight()},
                lifetime = .25,
                color = particleColor,
                opacity = 1,
                opacityDelta = -0.05
            })
        end



        local direction = string.sub(input, 1, #input - 1)
        local color = string.sub(input, #input, #input) == "L" and "red" or "blue"

        for index, inputData in pairs(game.inputList) do
            if direction == inputData[2] and color == inputData[3] then
                if math.abs(game.currentSong:tell() - inputData[1]) < game.perfectThreshold then
                    -- perfect hit
                    particle.create("hitConfirm", {
                        img = g.img.perfect,
                        position = {core.bumpX + (800 - 205), core.bumpY + 495},
                        lifetime = 0.5,

                        lifetimeMapping = {
                            {0.45,
                             {
                                 position = {core.bumpX + (800 - 205), core.bumpY + 490},
                             },
                            },
                            {0.3,
                             {
                                 position = {core.bumpX + (800 - 205), core.bumpY + 495}
                             }
                            }
                        }
                    })
                elseif math.abs(game.currentSong:tell() - inputData[1]) < game.niceThreshold then
                    particle.create("hitConfirm", {
                        img = g.img.nice,
                        position = {core.bumpX + (800 - 205), core.bumpY + 495},
                        lifetime = 0.5,

                        lifetimeMapping = {
                            {0.45,
                             {
                                 position = {core.bumpX + (800 - 205), core.bumpY + 490},
                             },
                            },
                            {0.3,
                             {
                                 position = {core.bumpX + (800 - 205), core.bumpY + 495}
                             }
                            }
                        }
                    })                end

                if math.abs(game.currentSong:tell() - inputData[1]) < game.niceThreshold then
                    game.inputList[index] = nil
                end
            end
        end

        -- handle cancel button
        if input == "cancel" then
            game.currentSong:stop()
            game_state = "GameDone"
        end


    elseif game_state == "Menu" then
        print(input)

        if input == "leftL" or input == "leftR" then
            menu.currentX = menu.currentX - 1
            menu.currentY = 1
        end
        if input == "rightL" or input == "rightR" then
            menu.currentX = menu.currentX + 1
            menu.currentY = 1
        end
        if input == "downL" or input == "downR" then
            menu.currentY = menu.currentY - 1
        end
        if input == "upL" or input == "upR" then
            menu.currentY = menu.currentY + 1
        end

        menu.currentX = core.clamp(menu.currentX, 1, 4)
        menu.currentY = core.clamp(menu.currentY, 1, #menu.taskList[menu.taskListKeys[menu.currentX]] + 1)

        -- handle actual menu button functions
        if input == "confirm" and menu.currentX == 1 and menu.currentY == 2 then
            le.quit()
        end
        if input == "confirm" and menu.currentX == 2 and menu.currentY == 2 then
            print("game start!!!")
            game_state = "InGame"
            game.init()
        end



    elseif game_state == "GameDone" then
        if input then
            game_state = "Menu"
        end
    end

end

function core.clamp(number, numberMin, numberMax)
    if number < numberMin then
        number = numberMin
    elseif number > numberMax then
        number = numberMax
    end
    return number
end

 -- NOTE: for drawing within the bounds of the game window, use game.draw()
function core.draw( drawable, x, y, r, sx, sy, ox, oy, kx, ky ) -- in place of love.graphics.draw()

    if type(drawable) == "string" then -- use lg.print to draw if string
        lg.print( drawable, x, y, r, sx, sy, ox, oy, kx, ky )
    else                               -- other drawable types use lg.draw
        -- converting the scale functionality to exact pixel measurements
        if sx then
            sx = (1 / drawable:getWidth()) * sx
        end

        if sy then
            sy = (1 / drawable:getHeight()) * sy
        end

        if ox then
            if ox == "left" then
                ox = 0
            elseif ox == "center" then
                ox = drawable:getWidth()/2
            elseif ox == "right" then
                ox = drawable:getWidth()
            end
        end

        if oy then
            if oy == "top" then
                oy = 0
            elseif oy == "center" then
                oy = drawable:getHeight()/2
            elseif oy == "bottom" then
                oy = drawable:getHeight()
            end
        end

        lg.draw( drawable, x, y, r, sx, sy, ox, oy, kx, ky )
    end

end


-- returns the aspect ratio of either a drawable or X and Y size
function core.aspectRatio(firstVal, secondVal)
    if secondVal then
        return (firstVal/secondVal)
    else
        return firstVal:getWidth()/firstVal:getHeight()
    end
end

function core.update(dt)

end


---------------------------------------------------------------------
-----------------------GLOBAL FUNCTIONS------------------------------

function g.render() -- the initial rendering function. handles rendering the desktop (and responsible for zoom)

    -- determine the window size
    core.sWidth, core.sHeight = lg.getDimensions()

    -- determine the "bump" values
    core.bumpX = (core.sWidth-800)/2
    core.bumpY = (core.sHeight-600)/2





    -------------------------------------screen zoom-----------------------------------
        local ratio
        if core.sWidth > core.sHeight then
            ratio = (core.sHeight/600)
        else
            ratio = (core.sWidth/800)
        end
        local wr = (ratio)-1
        local translateX = -(core.sWidth/(1/wr)/2)
        local translateY = -(core.sHeight/(1/wr)/2)

        lg.translate(translateX, translateY)
        lg.scale(ratio,ratio)
   ------------------------------------------------------------------------------------

    -- render desktop background
    lg.push()
    lg.setColor(1,1,1)
    core.draw(g.img.desktop,
            core.sWidth/2, core.sHeight/2,
            0,
            600*core.aspectRatio(g.img.desktop), 600,
            "center", "center")


    -- render the taskbar
    core.draw(g.img.taskbar,
            0, core.bumpY + 600,
            0,
            core.sWidth,
            36,
            "left", "bottom"
    )

    ------------------------------------------------------------------------------------

    -- render the start bar on taskbar
    game.draw(g.img.menuStart,
            6, 582,
            0,
            65,
            20,
            "left", "center"
    )



    -- render tasks
    for i = 1, 3 do
        game.draw(g.img.menuTask,
                menu.taskOffsetX[i + 1], 582,
                0,
                130,
                20,
                "left", "center"
        )
    end

    -- render time bar
    game.draw(g.img.time,
            700, 583,
            0,
            93,
            20,
            "left", "center"
    )

    lg.pop()
end



function g.loadSkin(skinName) -- loads a skin into memory
    for name, imagePath in pairs(g.imagePointers) do
        g.img[name] = lg.newImage("assets/skins/" .. skinName .. "/" .. imagePath)
    end

    for name, audioPath in pairs(g.soundPointers) do
        g.snd[name] = love.audio.newSource("assets/skins/" .. skinName .. "/sfx/" .. audioPath, "static")
        if name == "hitLeft" then
            g.snd[name]:setVolume(2)
        end
    end
end




---------------------------------------------------------------------
-----------------------GAME FUNCTIONS--------------------------------

-- NOTE: for drawing outside the bounds of the game window, use core.draw()
function game.draw( drawable, x, y, r, sx, sy, ox, oy, kx, ky ) -- in place of love.graphics.draw()
    x = x and x or 0 -- set x to 0 if it doesn't exist
    y = y and y or 0 -- set y to 0 if it doesn't exist
    core.draw( drawable, x + core.bumpX, y + core.bumpY, r, sx, sy, ox, oy, kx, ky )
end

function game.init()
    game.loadMap()
    game.currentSong:setVolume(g.songVolume)
    game.currentSong:setPitch(game.songSlowdown)

    if game.songPreview then game.currentSong:seek(game.songPreview) end

    game.currentSong:play()
    game.inputList = {}
end


-- creates a beat and adds it to the beat table
function game.createBeat(startTime, endTime, direction, color, position, iterations, frequency, opacity)
    table.insert(game.beats, {
        currentTime = startTime,
        opacity = opacity,
        startTime = startTime,
        endTime = endTime,
        direction = direction,
        color = color,
        position = position,
        iterations = iterations,
        frequency = frequency
    })

    table.insert(game.inputList,{
        endTime,
        direction,
        color
    })

end

-- function called to process and increase beat step
function game.processBeats(dt)
    if game.songSlowdown then dt = dt * game.songSlowdown end
    for index, beat in pairs(game.beats) do
        beat.currentTime = beat.currentTime + dt
        if beat.currentTime >= beat.endTime then
            if beat.iterations > 0 then
                local difference = beat.currentTime - beat.endTime
                beat.position = "inner"

                local swaps = {
                    right = "left",
                    left = "right",
                    up = "down",
                    down = "up"
                }

                print(beat.endTime + beat.frequency)

                game.createBeat(
                        beat.endTime,
                        beat.endTime + beat.frequency,
                        swaps[beat.direction],
                        beat.color,
                        "inner",
                        beat.iterations - 1,
                        beat.frequency,
                        beat.opacity
                )
            end

            game.beats[index] = nil
        end
    end

    for index, inputData in pairs(game.inputList) do
        if game.currentSong:tell() > (inputData[1] + game.niceThreshold) then
            game.inputList[index] = nil
            print("miss")
        end
    end


end

-- function called to render all current beats to the screen
function game.renderBeats()

    for _, beat in pairs(game.beats) do

        beat.opacity = beat.opacity and beat.opacity or 1

        lg.push()
        if beat.color == "red" then
            lg.setColor(1,0,0, beat.opacity)
        else
            lg.setColor(0.25,0.25,1, beat.opacity)
        end

        local ratio = (beat.currentTime - beat.startTime) / (beat.endTime - beat.startTime)
        local inverseRatio = 1 - ratio
        local xPos, yPos, ySize, xSize, rot = 0

        if beat.position == "outer" or not beat.position then


            --- CASE: IT IS LEFT
            if beat.direction == "left" then
                xPos = game.fieldOffset.x + (150 * ratio)
                yPos = game.fieldOffset.y + 250
                ySize = (300 * inverseRatio) + 200
                xSize = ySize * core.aspectRatio(g.img.beatOuterX)
            elseif beat.direction == "right" then
                xPos = game.fieldOffset.x + 500 - (150 * ratio)
                yPos = game.fieldOffset.y + 250
                ySize = -((300 * inverseRatio) + 200)
                xSize = ySize * core.aspectRatio(g.img.beatOuterX)
            elseif beat.direction == "up" then
                yPos = game.fieldOffset.y + (150 * ratio)
                xPos = game.fieldOffset.x + 250
                xSize = (300 * inverseRatio) + 200
                ySize = xSize * core.aspectRatio(g.img.beatOuterY)
            elseif beat.direction == "down" then
                yPos = game.fieldOffset.y + 500 - (150 * ratio)
                xPos = game.fieldOffset.x + 250
                xSize = -((300 * inverseRatio) + 200)
                ySize = xSize * core.aspectRatio(g.img.beatOuterY)
            end

            if beat.direction == "left" or beat.direction == "right" then
                game.draw(g.img.beatOuterX,
                        xPos, yPos,
                        rot,
                        xSize, ySize,
                        "left",
                        "center"
                )
            else
                game.draw(g.img.beatOuterY,
                        xPos, yPos,
                        rot,
                        xSize, ySize,
                        "center",
                        "top"
                )
            end
        elseif beat.position == "inner" then
            if beat.direction == "left" then
                xPos = game.fieldOffset.x + 150 + 200 - (200 * ratio)
                yPos = game.fieldOffset.y + 150
                ySize = 200
                xSize = 100



            elseif beat.direction == "right" then
                xPos = game.fieldOffset.x + 150 + (200 * ratio)
                yPos = game.fieldOffset.y + 150
                ySize = 200
                xSize = -100
            elseif beat.direction == "up" then
                yPos = game.fieldOffset.y + 150 + 200 - (200 * ratio)
                xPos = game.fieldOffset.x + 150
                ySize = 100
                xSize = 200
            elseif beat.direction == "down" then
                yPos = game.fieldOffset.y + 150 + (200 * ratio)
                xPos = game.fieldOffset.x + 150
                ySize = -100
                xSize = 200
            end


            if beat.direction == "left" or beat.direction == "right" then
                game.draw(g.img.beatInnerX,
                        xPos, yPos,
                        rot,
                        xSize, ySize,
                        "left",
                        "top"
                )
            else
                game.draw(g.img.beatInnerY,
                        xPos, yPos,
                        rot,
                        xSize, ySize,
                        "left",
                        "top"
                )
            end
        end
            lg.pop()
    end

    lg.push()
    lg.setColor(1,1,1)
    lg.pop()
end

function game.loadMap(mapName)
    game.currentMap = {
        -- MAP DATA
    }

    game.currentSong = love.audio.newSource(game.mapDirectory .. "testMap/song.mp3", "stream")
end


function game.render() -- this renders the game items (ex. play field, score, etc)
    lg.push()
    game.draw(g.img.playAreaWindow,
            game.fieldOffset.x - 6, game.fieldOffset.y - 18,
            0,
            512, 524
    )




    -- draw the play area BG
    game.draw(g.img.playAreaBg,
            game.fieldOffset.x, game.fieldOffset.y,
            0,
            500, 500
    )
    lg.pop()


    -- render beats here

    game.renderBeats()


    -- draw the play area foreground
    game.draw(g.img.playAreaForeground,
            game.fieldOffset.x, game.fieldOffset.y,
            0,
            500, 500
    )



    -- draw the center hit box
    --[[game.draw(g.img.hitZone,
            game.fieldOffset.x + 250, game.fieldOffset.y + 250,
            0,
            200, 200,
            "center", "center"
    )]]

    particle.draw()

    lg.push()
    lg.setColor(1,1,1)
    lg.pop()

    -- draw the hit zone foreground
    game.draw(g.img.hitZoneForeground,
            game.fieldOffset.x + 250, game.fieldOffset.y + 250,
            0,
            210, 210,
            "center", "center"
    )
    ---------------- render other windows
    -- draw the player status window
    game.draw(g.img.terminal,
            game.fieldOffset.x + 530, game.fieldOffset.y - 18,
            0,
            180, 320
    )

    -- draw the progress window
    game.draw(g.img.progressWindow,
            game.fieldOffset.x + 530, game.fieldOffset.y + 325,
            0,
            180, 100
    )

    game.draw(g.img.progressGraphic,
            game.fieldOffset.x + 530, game.fieldOffset.y + 325,
            0,
            180, 100
    )
end

function game.update(dt)
    game.processBeats(dt)

    if not game.currentSong then return end

    local associations = {}

    for position, beatData in pairs(game.beatmapData) do

        local direction
        local color
        local opacity = 1
        local c1 = string.sub(beatData[2], 1, 1)
        local c2 = string.sub(beatData[2], 2, 2)

        if c1 == "L" then
            direction = "left"
        elseif c1 == "R" then
            direction = "right"
        elseif c1 == "U" then
            direction = "up"
        else
            direction = "down"
        end

        if c2 == "1" then
            color = "red"
        else
            color = "blue"
        end

        if associations[c1 .. tostring(beatData[1])] == true then
            opacity = 0.5
        end

        associations[c1 .. tostring(beatData[1])] = true



        if game.currentSong:tell() >= (beatData[1] - game.approachRate) then
            game.createBeat(
                    game.currentSong:tell(),
                    beatData[1],
                    direction,
                    color,
                    "outer",
                    beatData[3] and beatData[3] or 0,
                    beatData[4],
                    opacity
            )

            game.beatmapData[position] = nil
        end
    end

    if #game.beatmapData == 0 and #inputData == 0 then

    end

end

---------------------------------------------------------------------
----------------------MENU FUNCTIONS---------------------------------

function menu.render()

    if menu.currentX == 1 then

        -- render contexts
        local currOffset = 0
        for _, selectedContext in pairs(menu.taskList.start) do
            game.draw(g.img.menuStartContext,
                    menu.taskOffsetX[1], 564 - currOffset,
                    0,
                    65,
                    36,
                    "left", "bottom"
            )
            currOffset = currOffset + 36
        end

        -- render the selected task or context
        if menu.currentY == 1 then
            game.draw(g.img.menuStartSelected,
                    menu.taskOffsetX[1], 582,
                    0,
                    65,
                    20,
                    "left", "center"
            )
        elseif menu.currentY == 2 then
            game.draw(g.img.menuStartContextSelected,
                    menu.taskOffsetX[1], 564,
                    0,
                    65,
                    36,
                    "left", "bottom"
            )
        end

    elseif menu.currentX == 2 then

        -- render contexts
        local currOffset = 0
        for _, selectedContext in pairs(menu.taskList.play) do
            game.draw(g.img.menuTaskContext,
                    menu.taskOffsetX[2], 564 - currOffset,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
            currOffset = currOffset + 36

            -- render the selected task or context
            if menu.currentY == 1 then
                game.draw(g.img.menuTaskSelected,
                        menu.taskOffsetX[2], 582,
                        0,
                        130,
                        20,
                        "left", "center"
                )
            elseif menu.currentY <= (#menu.taskList[menu.taskListKeys[menu.currentX]] + 1) then
                game.draw(g.img.menuTaskContextSelected,
                        menu.taskOffsetX[2], 564,
                        0,
                        130,
                        36,
                        "left", "bottom"
                )
            end

        end
    elseif menu.currentX == 3 then

        -- render contexts
        local currOffset = 0
        for _, selectedContext in pairs(menu.taskList.settings) do
            game.draw(g.img.menuTaskContext,
                    menu.taskOffsetX[3], 564 - currOffset,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
            currOffset = currOffset + 36
        end

        -- render the selected task or context
        if menu.currentY == 1 then
            game.draw(g.img.menuTaskSelected,
                    menu.taskOffsetX[3], 582,
                    0,
                    130,
                    20,
                    "left", "center"
            )
        elseif menu.currentY == 2 then
            game.draw(g.img.menuTaskContextSelected,
                    menu.taskOffsetX[3], 564,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
        elseif menu.currentY == 3 then
            game.draw(g.img.menuTaskContextSelected,
                    menu.taskOffsetX[3], 564 - 36,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
        end

    elseif menu.currentX == 4 then

        -- render contexts
        local currOffset = 0
        for _, selectedContext in pairs(menu.taskList.credits) do
            game.draw(g.img.menuTaskContext,
                    menu.taskOffsetX[4], 564 - currOffset,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
            currOffset = currOffset + 36
        end

        -- render the selected task or context
        if menu.currentY == 1 then
            game.draw(g.img.menuTaskSelected,
                    menu.taskOffsetX[4], 582,
                    0,
                    130,
                    20,
                    "left", "center"
            )
        elseif menu.currentY == 2 then
            game.draw(g.img.menuTaskContextSelected,
                    menu.taskOffsetX[4], 564,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
        elseif menu.currentY == 3 then
            game.draw(g.img.menuTaskContextSelected,
                    menu.taskOffsetX[4], 564 - 36,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
        elseif menu.currentY == 4 then
            game.draw(g.img.menuTaskContextSelected,
                    menu.taskOffsetX[4], 564 - 72,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
        elseif menu.currentY == 5 then
            game.draw(g.img.menuTaskContextSelected,
                    menu.taskOffsetX[4], 564 - 108,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
        end

    end

end

function menu.update(dt)

end