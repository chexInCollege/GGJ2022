---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chex.
--- DateTime: 1/28/2022 7:56 PM
---


--- global game tables
core = {} -- basic libraries and functions (core.draw, etc)
g = {}    -- holds all GLOBAL data (independent of game state)
game = {} -- holds all functions/vars relative to the game
menu = {} -- holds all functions/vars relative to the menu

--- love2d constants
lfs = love.filesystem
lg = love.graphics
ls = love.system
lw = love.window
lk = love.keyboard
le = love.event


------------------------ 'core' variables
-- determine the window size
core.sWidth, core.sHeight = lg.getDimensions()

-- determine the "bump" values
core.bumpX = (core.sWidth-800)/2
core.bumpY = (core.sHeight-600)/2

core.keyMaps = {
    left = "leftR",
    right = "rightR",
    up = "upR",
    down = "downR",

    a = "leftL",
    d = "rightL",
    w = "upL",
    s = "downL",

    ["return"] = "confirm",
    escape = "cancel"
}
------------------------ 'g' variables

-- stores all images used in the game
g.img = {}
g.imagePointers = {
    desktop = "desktop.png",
    playAreaBg = "playAreaBg.png",
    playAreaWindow = "playAreaWindow.png",
    playAreaForeground = "playAreaForeground.png",
    progressWindow = "progressWindow.png",
    menuTask = "task.png",
    menuTaskSelected = "taskSelected.png",
    menuTaskContext = "taskContext.png",
    menuTaskContextSelected = "taskContextSelected.png",
    menuStart = "start.png",
    menuStartSelected = "startSelected.png",
    menuStartContext = "startContext.png",
    menuStartContextSelected = "startContextSelected.png",
    taskbar = "taskbar.png",
    terminal = "terminal.png",
    hitZone = "hitZone.png",
    hitZoneForeground = "hitZoneForeground.png",
    beatInnerX = "beatInnerX.png",
    beatOuterX = "beatOuterX.png",
    beatInnerY = "beatInnerY.png",
    beatOuterY = "beatOuterY.png",
    progressGraphic = "progressGraphic.png",
    nice = "nice.png",
    perfect = "perfect.png",
    time = "time.png",
    popUp = "popUp.png",
    popUpBig = "popUpBig.png",
    health = "health.png",
    hitArrow = "hitArrow.png",
}

g.snd = {}
g.soundPointers = {
    hitLeft = "hitLeft.ogg",
    hitRight = "hitRight.ogg",
    menuNavX = "menuNavX.ogg",
    menuNavY = "menuNavY.ogg",
    tada = "tada.mp3",
    chord = "chord.mp3"
}

g.sfxVolume = 1
g.songVolume = 0.5
------------------------ 'game' variables

game.fieldOffset = {x = 50, y = 40}

game.beats = {}

game.songSlowdown = (140/120)

game.mapDirectory = "assets/maps/"
game.currentSong = false
game.currentMap = {}

game.approachRate = 0.45
game.niceThreshold = 0.2/2
game.perfectThreshold = 0.1/2
game.missThreshold = 0.4

game.hitArrowColors = {
    left = {0,0,0},
    right = {0,0,0},
    up = {0,0,0},
    down = {0,0,0}
}


--- beatmap structure:
--- {
---     {
---         timestamp,
---         "U2"
---     }
--- }

game.beatmapData = {}

--[[
    {
        2.50,
        "R2",
        4,
        .5
    },
]]

------------------------ 'menu' variables

menu.currentX = 1
menu.currentY = 2
menu.taskList = {
    start = { "exit" },
    play = { "demo" },
    settings = { "song volume", "sfx volume" },
    credits = { "code", "graphics", "songs", "sfx" }
}
menu.taskListKeys = {
    "start", "play", "settings", "credits"
}

menu.taskOffsetX = {
    6, 77, 212, 348
}


---------------------------------------------------------------------
-------------------------CORE FUNCTIONS------------------------------

function core.clone( Table, Cache ) -- Makes a deep copy of a table.
    if type( Table ) ~= 'table' then
        return Table
    end

    Cache = Cache or {}
    if Cache[Table] then
        return Cache[Table]
    end

    local New = {}
    Cache[Table] = New
    for Key, Value in pairs( Table ) do
        New[core.clone( Key, Cache)] = core.clone( Value, Cache )
    end

    return New
end

function core.generate_timestamp(input)
    local minutes = 0
    local seconds = math.floor(input)
    local ms = input - math.floor(input)

    while seconds > 59 do
        seconds = seconds - 60
        minutes = minutes + 1
    end

    if minutes < 10 then
        minutes = "0" .. tostring(minutes)
    end

    if seconds < 10 then
        seconds = "0" .. tostring(seconds)
    end

    ms = math.floor(ms*100)/100

    if string.len(ms) == 3 then
        ms = string.sub(tostring(ms), 2,#tostring(ms)) .. "0"
    else
        ms = string.sub(tostring(ms), 2,#tostring(ms))
    end
    return minutes..":"..seconds..ms
end

function core.cleanTable(tab)
    local tab2 = {}

    for _, item in pairs(tab) do
        table.insert(tab2, item)
    end

    return tab2
end

function core.playSound(audio)
    audio:stop()
    audio:setVolume(g.sfxVolume)
    audio:play()
end

function core.checkInput(key)
    local input = core.keyMaps[key] and core.keyMaps[key] or "unmapped"

    if input == "unmapped" then return end -- fuck it

    if game_state == "InGame" then

        print(input)

        local particleColor
        if string.sub(input, #input, #input) == "R" then
            particleColor = {.2,.25,1}
            g.snd.hitLeft:setPitch(1.25)
            core.playSound(g.snd.hitLeft)
        else
            particleColor = {1,.2,.25}
            g.snd.hitLeft:setPitch(1)
            core.playSound(g.snd.hitLeft)
        end

        if input == "leftL" or input == "leftR" then
            particle.create({
                img = g.img.beatInnerX,
                position = {core.bumpX + game.fieldOffset.x + 150, core.bumpY + game.fieldOffset.y + 150},
                velocity = {-.35,0},
                scale = {150/g.img.beatInnerX:getWidth(), 200/g.img.beatInnerX:getHeight()},
                lifetime = .25,
                color = particleColor,
                opacity = 1,
                opacityDelta = -0.05
            })
        elseif input == "rightL" or input == "rightR" then
            particle.create({
                img = g.img.beatInnerX,
                position = {core.bumpX + game.fieldOffset.x + 335, core.bumpY + game.fieldOffset.y + 150},
                velocity = {.25,0},
                scale = {150/g.img.beatInnerX:getWidth(), 200/g.img.beatInnerX:getHeight()},
                lifetime = .25,
                color = particleColor,
                opacity = 1,
                opacityDelta = -0.05
            })

        elseif input == "upL" or input == "upR" then
            particle.create({
                img = g.img.beatInnerY,
                position = {core.bumpX + game.fieldOffset.x + 150, core.bumpY + game.fieldOffset.y + 150},
                velocity = {0,-.25},
                scale = {200/g.img.beatInnerY:getWidth(), 150/g.img.beatInnerY:getHeight()},
                lifetime = .25,
                color = particleColor,
                opacity = 1,
                opacityDelta = -0.05
            })
        elseif input == "downL" or input == "downR" then
            particle.create({
                img = g.img.beatInnerY,
                position = {core.bumpX + game.fieldOffset.x + 150, core.bumpY + game.fieldOffset.y + 335},
                velocity = {0,.25},
                scale = {200/g.img.beatInnerY:getWidth(), 150/g.img.beatInnerY:getHeight()},
                lifetime = .25,
                color = particleColor,
                opacity = 1,
                opacityDelta = -0.05
            })
        end



        local direction = string.sub(input, 1, #input - 1)
        local color = string.sub(input, #input, #input) == "L" and "red" or "blue"

        game.hitArrowColors[direction] = {particleColor[1] / 6, particleColor[2] / 6, particleColor[3] / 6}


        for index, inputData in pairs(game.inputList) do
            if direction == inputData[2] and color == inputData[3] then
                if math.abs(game.currentSong:tell() - inputData[1]) < game.perfectThreshold then
                    -- perfect hit
                    game.perfectCount = game.perfectCount + 1
                    game.hitArrowColors[direction] = {0, .2, 0}
                    game.score = game.score + 300
                    particle.create("hitConfirm", {
                        img = g.img.perfect,
                        position = {core.bumpX + (800 - 205), core.bumpY + 495},
                        lifetime = 0.5,

                        lifetimeMapping = {
                            {0.45,
                             {
                                 position = {core.bumpX + (800 - 205), core.bumpY + 490},
                             },
                            },
                            {0.3,
                             {
                                 position = {core.bumpX + (800 - 205), core.bumpY + 495}
                             }
                            }
                        }
                    })
                elseif math.abs(game.currentSong:tell() - inputData[1]) < game.niceThreshold then
                    game.score = game.score + 100

                    game.niceCount = game.niceCount + 1
                    game.hitArrowColors[direction] = {87/255, 60/255, 0}
                    particle.create("hitConfirm", {
                        img = g.img.nice,
                        position = {core.bumpX + (800 - 205), core.bumpY + 495},
                        lifetime = 0.5,

                        lifetimeMapping = {
                            {0.45,
                             {
                                 position = {core.bumpX + (800 - 205), core.bumpY + 490},
                             },
                            },
                            {0.3,
                             {
                                 position = {core.bumpX + (800 - 205), core.bumpY + 495}
                             }
                            }
                        }
                    })
                elseif math.abs(game.currentSong:tell() - inputData[1]) < game.missThreshold then
                    game.hitArrowColors[direction] = {0.5, 0, 0}

                    particle.create("hitConfirm", {
                        text = "MISS",
                        position = {core.bumpX + (800 - 205), core.bumpY + 495},
                        lifetime = 0.5,

                        lifetimeMapping = {
                            {0.45,
                             {
                                 position = {core.bumpX + (800 - 205), core.bumpY + 490},
                             },
                            },
                            {0.3,
                             {
                                 position = {core.bumpX + (800 - 205), core.bumpY + 495}
                             }
                            }
                        }
                    })
                    game.missCount = game.missCount + 1
                    game.inputList[index] = nil
                end

                if math.abs(game.currentSong:tell() - inputData[1]) < game.niceThreshold then
                    game.inputList[index] = nil
                    game.hp = game.hp + game.hpDrain/2
                end
            end
        end

        -- handle cancel button
        if input == "cancel" then
            game.currentSong:stop()
            game_state = "GameDone"
        end


    elseif game_state == "Menu" then
        print(input)

        if input == "leftL" or input == "leftR" then
            menu.currentX = menu.currentX - 1
            menu.currentY = 1
            core.playSound(g.snd.menuNavX)
        end
        if input == "rightL" or input == "rightR" then
            menu.currentX = menu.currentX + 1
            menu.currentY = 1
            core.playSound(g.snd.menuNavX)
        end
        if input == "downL" or input == "downR" then
            menu.currentY = menu.currentY - 1
            core.playSound(g.snd.menuNavY)
        end
        if input == "upL" or input == "upR" then
            menu.currentY = menu.currentY + 1
            core.playSound(g.snd.menuNavY)
        end

        menu.currentX = core.clamp(menu.currentX, 1, 4)
        menu.currentY = core.clamp(menu.currentY, 2, #menu.taskList[menu.taskListKeys[menu.currentX]] + 1)

        if input == "confirm" then
            core.playSound(g.snd.menuNavX)
            core.playSound(g.snd.menuNavY)
        end

        -- handle actual menu button functions
        if input == "confirm" and menu.currentX == 1 and menu.currentY == 2 then
            le.quit()
        end
        if input == "confirm" and menu.currentX == 2 and menu.currentY == 2 then
            print("game start!!!")
            game_state = "InGame"
            game.init()
        end
        if input == "confirm" and menu.currentX == 3 and menu.currentY == 2 then
            if (g.songVolume < 0.9) then
                g.songVolume = g.songVolume + 0.1
            else
                g.songVolume = 0.0
            end
        end
        if input == "confirm" and menu.currentX == 3 and menu.currentY == 3 then
            if (g.sfxVolume < 0.9) then
                g.sfxVolume = g.sfxVolume + 0.1
            else
                g.sfxVolume = 0.0
            end
        end



    elseif game_state == "GameDone" then
        if input then
            game_state = "Menu"
        end
    end

end

function core.clamp(number, numberMin, numberMax)
    if number < numberMin then
        number = numberMin
    elseif number > numberMax then
        number = numberMax
    end
    return number
end

 -- NOTE: for drawing within the bounds of the game window, use game.draw()
function core.draw( drawable, x, y, r, sx, sy, ox, oy, kx, ky ) -- in place of love.graphics.draw()

    if type(drawable) == "string" then -- use lg.print to draw if string
        lg.print( drawable, x, y, r, sx, sy, ox, oy, kx, ky )
    else                               -- other drawable types use lg.draw
        -- converting the scale functionality to exact pixel measurements
        if sx then
            sx = (1 / drawable:getWidth()) * sx
        end

        if sy then
            sy = (1 / drawable:getHeight()) * sy
        end

        if ox then
            if ox == "left" then
                ox = 0
            elseif ox == "center" then
                ox = drawable:getWidth()/2
            elseif ox == "right" then
                ox = drawable:getWidth()
            end
        end

        if oy then
            if oy == "top" then
                oy = 0
            elseif oy == "center" then
                oy = drawable:getHeight()/2
            elseif oy == "bottom" then
                oy = drawable:getHeight()
            end
        end

        lg.draw( drawable, x, y, r, sx, sy, ox, oy, kx, ky )
    end

end


-- returns the aspect ratio of either a drawable or X and Y size
function core.aspectRatio(firstVal, secondVal)
    if secondVal then
        return (firstVal/secondVal)
    else
        return firstVal:getWidth()/firstVal:getHeight()
    end
end

function core.update(dt)
    dt = dt
end


---------------------------------------------------------------------
-----------------------GLOBAL FUNCTIONS------------------------------

function g.render() -- the initial rendering function. handles rendering the desktop (and responsible for zoom)

    -- determine the window size
    core.sWidth, core.sHeight = lg.getDimensions()

    -- determine the "bump" values
    core.bumpX = (core.sWidth-800)/2
    core.bumpY = (core.sHeight-600)/2





    -------------------------------------screen zoom-----------------------------------
        local ratio
        if core.sWidth > core.sHeight then
            ratio = (core.sHeight/600)
        else
            ratio = (core.sWidth/800)
        end
        local wr = (ratio)-1
        local translateX = -(core.sWidth/(1/wr)/2)
        local translateY = -(core.sHeight/(1/wr)/2)

        lg.translate(translateX, translateY)
        lg.scale(ratio,ratio)
   ------------------------------------------------------------------------------------

    -- render desktop background
    lg.push()
    lg.setColor(1,1,1)
    core.draw(g.img.desktop,
            core.sWidth/2, core.sHeight/2,
            0,
            600*core.aspectRatio(g.img.desktop), 600,
            "center", "center")


    -- render the taskbar
    core.draw(g.img.taskbar,
            0, core.bumpY + 600,
            0,
            core.sWidth,
            36,
            "left", "bottom"
    )

    ------------------------------------------------------------------------------------

    -- render the start bar on taskbar
    game.draw(g.img.menuStart,
            6, 582,
            0,
            65,
            20,
            "left", "center"
    )



    -- render tasks
    for i = 1, 3 do
        game.draw(g.img.menuTask,
                menu.taskOffsetX[i + 1], 582,
                0,
                130,
                20,
                "left", "center"
        )
    end

    -- render time bar
    game.draw(g.img.time,
            700, 582,
            0,
            93,
            20,
            "left", "center"
    )

    lg.pop()
end



function g.loadSkin(skinName) -- loads a skin into memory
    for name, imagePath in pairs(g.imagePointers) do
        g.img[name] = lg.newImage("assets/skins/" .. skinName .. "/" .. imagePath)
    end

    for name, audioPath in pairs(g.soundPointers) do
        g.snd[name] = love.audio.newSource("assets/skins/" .. skinName .. "/sfx/" .. audioPath, "static")
        if name == "hitLeft" then
            g.snd[name]:setVolume(2)
        end
    end

    lg.setFont(lg.newFont("/assets/skins/"..skinName.."/font.ttf", 16))

end




---------------------------------------------------------------------
-----------------------GAME FUNCTIONS--------------------------------

-- NOTE: for drawing outside the bounds of the game window, use core.draw()
function game.draw( drawable, x, y, r, sx, sy, ox, oy, kx, ky ) -- in place of love.graphics.draw()
    x = x and x or 0 -- set x to 0 if it doesn't exist
    y = y and y or 0 -- set y to 0 if it doesn't exist
    core.draw( drawable, x + core.bumpX, y + core.bumpY, r, sx, sy, ox, oy, kx, ky )
end

function game.init()
    game.loadMap()
    game.currentSong:setVolume(g.songVolume)
    game.currentSong:setPitch(game.songSlowdown)

    if game.songPreview then game.currentSong:seek(game.songPreview) end

    game.currentSong:play()
    game.inputList = {}
    game.beatCount = 0
    game.score = 0

    game.perfectCount = 0
    game.niceCount = 0
    game.missCount = 0
    game.accuracy = 0

    game.hpDrain = 1.5
    game.hp = 10

    game.beats = {}
    game.inputList = {}

    -- (temp)
    game.beatmapData = core.clone(game.beatmapDataTemplate)
    game.totalBeats = 0

    for _, beat in pairs(game.beatmapData) do
        game.totalBeats = game.totalBeats + 1
        if beat[3] then
            game.totalBeats = game.totalBeats + beat[3]
        end
    end
end


-- creates a beat and adds it to the beat table
function game.createBeat(startTime, endTime, direction, color, position, iterations, frequency, opacity)
    table.insert(game.beats, {
        currentTime = startTime,
        opacity = opacity,
        startTime = startTime,
        endTime = endTime,
        direction = direction,
        color = color,
        position = position,
        iterations = iterations,
        frequency = frequency
    })

    table.insert(game.inputList,{
        endTime,
        direction,
        color
    })

end

-- function called to process and increase beat step
function game.processBeats(dt)
    if game.songSlowdown then dt = dt * game.songSlowdown end
    for index, beat in pairs(game.beats) do
        beat.currentTime = beat.currentTime + dt
        if beat.currentTime >= beat.endTime then
            if beat.iterations > 0 then
                beat.position = "inner"

                local swaps = {
                    right = "left",
                    left = "right",
                    up = "down",
                    down = "up"
                }

                print(beat.endTime + beat.frequency)

                game.createBeat(
                        beat.endTime,
                        beat.endTime + beat.frequency,
                        swaps[beat.direction],
                        beat.color,
                        "inner",
                        beat.iterations - 1,
                        beat.frequency,
                        beat.opacity
                )
            end

            game.beats[index] = nil

            --if beat.iterations == 0 then
                game.beatCount = game.beatCount + 1
            --end
        end
    end

    for index, inputData in pairs(game.inputList) do
        if game.currentSong:tell() > (inputData[1] + game.niceThreshold) then
            game.inputList[index] = nil
            game.hp = game.hp - game.hpDrain
            game.missCount = game.missCount + 1
        end
    end


end



-- function called to render all current beats to the screen
function game.renderBeats()

    for _, beat in pairs(game.beats) do

        beat.opacity = beat.opacity and beat.opacity or 1

        lg.push()
        if beat.color == "red" then
            lg.setColor(1,0,0, beat.opacity)
        else
            lg.setColor(0.25,0.25,1, beat.opacity)
        end

        local ratio = (beat.currentTime - beat.startTime) / (beat.endTime - beat.startTime)
        local inverseRatio = 1 - ratio
        local xPos, yPos, ySize, xSize, rot = 0

        if beat.position == "outer" or not beat.position then


            --- CASE: IT IS LEFT
            if beat.direction == "left" then
                xPos = game.fieldOffset.x + (150 * ratio)
                yPos = game.fieldOffset.y + 250
                ySize = (300 * inverseRatio) + 200
                xSize = ySize * core.aspectRatio(g.img.beatOuterX)
            elseif beat.direction == "right" then
                xPos = game.fieldOffset.x + 500 - (150 * ratio)
                yPos = game.fieldOffset.y + 250
                ySize = -((300 * inverseRatio) + 200)
                xSize = ySize * core.aspectRatio(g.img.beatOuterX)
            elseif beat.direction == "up" then
                yPos = game.fieldOffset.y + (150 * ratio)
                xPos = game.fieldOffset.x + 250
                xSize = (300 * inverseRatio) + 200
                ySize = xSize * core.aspectRatio(g.img.beatOuterY)
            elseif beat.direction == "down" then
                yPos = game.fieldOffset.y + 500 - (150 * ratio)
                xPos = game.fieldOffset.x + 250
                xSize = -((300 * inverseRatio) + 200)
                ySize = xSize * core.aspectRatio(g.img.beatOuterY)
            end

            if beat.direction == "left" or beat.direction == "right" then
                game.draw(g.img.beatOuterX,
                        xPos, yPos,
                        rot,
                        xSize, ySize,
                        "left",
                        "center"
                )
            else
                game.draw(g.img.beatOuterY,
                        xPos, yPos,
                        rot,
                        xSize, ySize,
                        "center",
                        "top"
                )
            end
        elseif beat.position == "inner" then
            if beat.direction == "left" then
                xPos = game.fieldOffset.x + 150 + 200 - (200 * ratio)
                yPos = game.fieldOffset.y + 150
                ySize = 200
                xSize = 100



            elseif beat.direction == "right" then
                xPos = game.fieldOffset.x + 150 + (200 * ratio)
                yPos = game.fieldOffset.y + 150
                ySize = 200
                xSize = -100
            elseif beat.direction == "up" then
                yPos = game.fieldOffset.y + 150 + 200 - (200 * ratio)
                xPos = game.fieldOffset.x + 150
                ySize = 100
                xSize = 200
            elseif beat.direction == "down" then
                yPos = game.fieldOffset.y + 150 + (200 * ratio)
                xPos = game.fieldOffset.x + 150
                ySize = -100
                xSize = 200
            end


            if beat.direction == "left" or beat.direction == "right" then
                game.draw(g.img.beatInnerX,
                        xPos, yPos,
                        rot,
                        xSize, ySize,
                        "left",
                        "top"
                )
            else
                game.draw(g.img.beatInnerY,
                        xPos, yPos,
                        rot,
                        xSize, ySize,
                        "left",
                        "top"
                )
            end
        end
            lg.pop()
    end

    lg.push()
    lg.setColor(1,1,1)
    lg.pop()
end

function game.loadMap(mapName)

    game.currentMap = {
        -- MAP DATA
    }

    game.currentSong = love.audio.newSource(game.mapDirectory .. "testMap/song.mp3", "stream")
end


function game.render() -- this renders the game items (ex. play field, score, etc)
    lg.push()
    game.draw(g.img.playAreaWindow,
            game.fieldOffset.x - 6, game.fieldOffset.y - 18,
            0,
            512, 524
    )




    -- draw the play area BG
    game.draw(g.img.playAreaBg,
            game.fieldOffset.x, game.fieldOffset.y,
            0,
            500, 500
    )
    lg.pop()

    -- draw the hit arrows
    lg.push()
    lg.setColor(0.15 + game.hitArrowColors.up[1],0.15 + game.hitArrowColors.up[2],0.15 + game.hitArrowColors.up[3])
    game.draw(g.img.hitArrow,
            game.fieldOffset.x + 250,
            game.fieldOffset.y + 100, 0,
            100, 50,
            "center","center")
    lg.pop()

    lg.push()
    lg.setColor(0.15 + game.hitArrowColors.down[1],0.15 + game.hitArrowColors.down[2],0.15 + game.hitArrowColors.down[3])
    game.draw(g.img.hitArrow,
            game.fieldOffset.x + 250,
            game.fieldOffset.y + 400, math.rad(180),
            100, 50,
            "center","center")
    lg.pop()

    lg.push()
    lg.setColor(0.15 + game.hitArrowColors.left[1],0.15 + game.hitArrowColors.left[2],0.15 + game.hitArrowColors.left[3])
    game.draw(g.img.hitArrow,
            game.fieldOffset.x + 100,
            game.fieldOffset.y + 250, math.rad(-90),
            100, 50,
            "center","center")
    lg.pop()

    lg.push()
    lg.setColor(0.15 + game.hitArrowColors.right[1],0.15 + game.hitArrowColors.right[2],0.15 + game.hitArrowColors.right[3])
    game.draw(g.img.hitArrow,
            game.fieldOffset.x + 400,
            game.fieldOffset.y + 250, math.rad(90),
            100, 50,
            "center","center")
    lg.pop()

    -- render beats
    game.renderBeats()

    lg.push()
    -- draw the play area foreground
    game.draw(g.img.playAreaForeground,
            game.fieldOffset.x, game.fieldOffset.y,
            0,
            500, 500
    )
    lg.pop()


    -- draw the center hit box
    --[[game.draw(g.img.hitZone,
            game.fieldOffset.x + 250, game.fieldOffset.y + 250,
            0,
            200, 200,
            "center", "center"
    )]]

    particle.draw()

    lg.push()
    lg.setColor(1,1,1)
    lg.pop()

    -- draw the hit zone foreground
    game.draw(g.img.hitZoneForeground,
            game.fieldOffset.x + 250, game.fieldOffset.y + 250,
            0,
            210, 210,
            "center", "center"
    )
    ---------------- render other windows
    -- draw the player status window
    game.draw(g.img.terminal,
            game.fieldOffset.x + 530, game.fieldOffset.y - 18,
            0,
            180, 320
    )

    game.draw("SCORE: " .. tostring(game.score),
            game.fieldOffset.x + 540, game.fieldOffset.y + 10
    )

    game.accuracy = game.beatCount > 0 and game.accuracy or 0
    local acc_str = string.sub(tostring(game.accuracy * 100), 1, 5) .. "%"
    game.draw("ACCURACY: " .. acc_str,
            game.fieldOffset.x + 540, game.fieldOffset.y + 30
    )

    game.draw("HP: ",
            game.fieldOffset.x + 540, game.fieldOffset.y + 70
    )

    for i = 1, game.hp do
        game.draw(g.img.health,
                game.fieldOffset.x + 530 + (i * 15), game.fieldOffset.y + 90, 0,
                15,15
        )
    end

    -- draw the progress window
    game.draw(g.img.progressWindow,
            game.fieldOffset.x + 530, game.fieldOffset.y + 325,
            0,
            180, 100
    )

    game.draw(g.img.progressGraphic,
            game.fieldOffset.x + 530, game.fieldOffset.y + 325,
            0,
            180, 100
    )
end

function game.update(dt)
    game.processBeats(dt)

    if not game.currentSong then return end

    -- process hit arrows
    for index, arrow in pairs(game.hitArrowColors) do
        for i = 1, 3 do
            game.hitArrowColors[index][i] = core.clamp(game.hitArrowColors[index][i] - (0.01 * 60 * dt), 0, 1)
        end
    end


    game.accuracy = (game.perfectCount + game.niceCount*0.6667) / game.beatCount

    game.hp = core.clamp(game.hp, 0, 10)

    local associations = {}

    for position, beatData in pairs(game.beatmapData) do

        local direction
        local color
        local opacity = 1
        local c1 = string.sub(beatData[2], 1, 1)
        local c2 = string.sub(beatData[2], 2, 2)

        if c1 == "L" then
            direction = "left"
        elseif c1 == "R" then
            direction = "right"
        elseif c1 == "U" then
            direction = "up"
        else
            direction = "down"
        end

        if c2 == "1" then
            color = "red"
        else
            color = "blue"
        end

        if associations[c1 .. tostring(beatData[1])] == true then
            opacity = 0.5
        end

        associations[c1 .. tostring(beatData[1])] = true



        if game.currentSong:tell() >= (beatData[1] - game.approachRate) then
            game.createBeat(
                    game.currentSong:tell(),
                    beatData[1],
                    direction,
                    color,
                    "outer",
                    beatData[3] and beatData[3] or 0,
                    beatData[4],
                    opacity
            )

            game.beatmapData[position] = nil
        end
    end

    if game.beatCount >= game.totalBeats and #game.inputList == 0 then
        game.currentSong:stop()
        game_state = "Menu"
    end

end

---------------------------------------------------------------------
----------------------MENU FUNCTIONS---------------------------------

function menu.render()

    --lg.setColor(1,1,1)


    if menu.currentX == 1 then

        -- render contexts
        local currOffset = 0
        for _, selectedContext in pairs(menu.taskList.start) do
            game.draw(g.img.menuStartContext,
                    menu.taskOffsetX[1], 564 - currOffset,
                    0,
                    65,
                    36,
                    "left", "bottom"
            )
            currOffset = currOffset + 36
        end

        -- render the selected task or context
        if menu.currentY == 1 then
            game.draw(g.img.menuStartSelected,
                    menu.taskOffsetX[1], 582,
                    0,
                    65,
                    20,
                    "left", "center"
            )
        elseif menu.currentY == 2 then
            game.draw(g.img.menuStartContextSelected,
                    menu.taskOffsetX[1], 564,
                    0,
                    65,
                    36,
                    "left", "bottom"
            )
        end

        lg.push()
        lg.setColor(0,0,0)
        game.draw("Exit",
                menu.taskOffsetX[1] + 22, 538,
                0
        )
        lg.pop()

    elseif menu.currentX == 2 then

        -- render contexts
        local currOffset = 0
        for _, selectedContext in pairs(menu.taskList.play) do
            game.draw(g.img.menuTaskContext,
                    menu.taskOffsetX[2], 564 - currOffset,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
            currOffset = currOffset + 36

            -- render the selected task or context
            if menu.currentY == 1 then
                game.draw(g.img.menuTaskSelected,
                        menu.taskOffsetX[2], 582,
                        0,
                        130,
                        20,
                        "left", "center"
                )
            elseif menu.currentY <= (#menu.taskList[menu.taskListKeys[menu.currentX]] + 1) then
                game.draw(g.img.menuTaskContextSelected,
                        menu.taskOffsetX[2], 564,
                        0,
                        130,
                        36,
                        "left", "bottom"
                )
            end

        end

        lg.push()
        lg.setColor(0,0,0)
        game.draw("I'll have what...",
                menu.taskOffsetX[2] + 22, 538,
                0
        )
        lg.pop()

    elseif menu.currentX == 3 then

        -- render contexts
        local currOffset = 0
        for _, selectedContext in pairs(menu.taskList.settings) do
            game.draw(g.img.menuTaskContext,
                    menu.taskOffsetX[3], 564 - currOffset,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
            currOffset = currOffset + 36
        end

        -- render the selected task or context
        if menu.currentY == 1 then
            game.draw(g.img.menuTaskSelected,
                    menu.taskOffsetX[3], 582,
                    0,
                    130,
                    20,
                    "left", "center"
            )
        elseif menu.currentY == 2 then
            game.draw(g.img.menuTaskContextSelected,
                    menu.taskOffsetX[3], 564,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
            game.draw(g.img.popUp,
                    400, 250,
                    0,
                    280,
                    200,
                    "center", "center"
            )
            game.draw("Song Volume \n _______________________ \n\nCurrent Volume: " .. (g.songVolume * 100) .. "%\n\nPress 'Enter' to adjust",
                    280, 180,
                    0
            )

        elseif menu.currentY == 3 then
            game.draw(g.img.menuTaskContextSelected,
                    menu.taskOffsetX[3], 564 - 36,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
            game.draw(g.img.popUp,
                    400, 250,
                    0,
                    280,
                    200,
                    "center", "center"
            )
            game.draw("SFX Volume \n _______________________ \n\nCurrent Volume: " .. (g.sfxVolume * 100) .. "%\n\nPress 'Enter' to adjust",
                    280, 180,
                    0
            )


        end

        lg.push()
        lg.setColor(0,0,0)
        game.draw("SFX Volume",
                menu.taskOffsetX[3] + 22, 538 - 36,
                0
        )
        game.draw("Song Volume",
                menu.taskOffsetX[3] + 22, 538,
                0
        )
        lg.pop()

    elseif menu.currentX == 4 then

        -- render contexts
        local currOffset = 0
        for _, selectedContext in pairs(menu.taskList.credits) do
            game.draw(g.img.menuTaskContext,
                    menu.taskOffsetX[4], 564 - currOffset,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
            currOffset = currOffset + 36
        end

        -- render the selected task or context
        if menu.currentY == 1 then
            game.draw(g.img.menuTaskSelected,
                    menu.taskOffsetX[4], 582,
                    0,
                    130,
                    20,
                    "left", "center"
            )
        elseif menu.currentY == 2 then
            game.draw(g.img.menuTaskContextSelected,
                    menu.taskOffsetX[4], 564,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
            game.draw(g.img.popUp,
                    400, 250,
                    0,
                    280,
                    200,
                    "center", "center"
            )
            game.draw("Code \n _______________________ \n\nCofC Global Game Jam 2022\n\nAlex Groves\nAlex Tate-Moffo",
                    280, 180,
                    0
            )

        elseif menu.currentY == 3 then
            game.draw(g.img.menuTaskContextSelected,
                    menu.taskOffsetX[4], 564 - 36,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
            game.draw(g.img.popUp,
                    400, 250,
                    0,
                    280,
                    200,
                    "center", "center"
            )
            game.draw("Graphics \n _______________________ \n\nCofC Global Game Jam 2022\n\nAlex Tate-Moffo",
                    280, 180,
                    0
            )

        elseif menu.currentY == 4 then
            game.draw(g.img.menuTaskContextSelected,
                    menu.taskOffsetX[4], 564 - 72,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
            game.draw(g.img.popUp,
                    400, 250,
                    0,
                    280,
                    200,
                    "center", "center"
            )
            game.draw("Songs \n _______________________ \n\n'I'll Have What She's Having'\nby WOOZE",
                    280, 180,
                    0
            )

        elseif menu.currentY == 5 then
            game.draw(g.img.menuTaskContextSelected,
                    menu.taskOffsetX[4], 564 - 108,
                    0,
                    130,
                    36,
                    "left", "bottom"
            )
            game.draw(g.img.popUp,
                    400, 250,
                    0,
                    280,
                    200,
                    "center", "center"
            )
            game.draw("SFX \n _______________________ \n\nAlex Groves\nWindows 95 System Sounds",
                    280, 180,
                    0
            )

        end



        lg.push()
        lg.setColor(0,0,0)
        game.draw("SFX",
                menu.taskOffsetX[4] + 22, 538 - 108,
                0
        )
        game.draw("Songs",
                menu.taskOffsetX[4] + 22, 538 - 72,
                0
        )
        game.draw("Graphics",
                menu.taskOffsetX[4] + 22, 538 - 36,
                0
        )
        game.draw("Code",
                menu.taskOffsetX[4] + 22, 538,
                0
        )
        lg.pop()

    end

    lg.push()
    lg.setColor(0,0,0)
    game.draw("Start",
            menu.taskOffsetX[1] + 22, 574,
            0
    )
    game.draw("Play Beatmap",
            menu.taskOffsetX[2] + 22, 574,
            0
    )
    game.draw("Volume Settings",
            menu.taskOffsetX[3] + 22, 574,
            0
    )
    game.draw("View Credits",
            menu.taskOffsetX[4] + 22, 574,
            0
    )
    game.draw("0:00 MIN",
            733, 574,
            0
    )

    lg.pop()


end

function menu.update(dt)

end