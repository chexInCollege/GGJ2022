---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chex.
--- DateTime: 1/28/2022 7:56 PM
---


--- global game tables
core = {} -- basic libraries and functions (core.draw, etc)
g = {}    -- holds all GLOBAL data (independent of game state)
game = {} -- holds all functions/vars relative to the game
menu = {} -- holds all functions/vars relative to the menu

--- love2d constants
lfs = love.filesystem
lg = love.graphics
ls = love.system
lw = love.window
lk = love.keyboard


------------------------ 'core' variables
-- determine the window size
core.sWidth, core.sHeight = lg.getDimensions()

-- determine the "bump" values
core.bumpX = (core.sWidth-800)/2
core.bumpY = (core.sHeight-600)/2

core.keyMaps = {
    left = "leftR",
    right = "rightR",
    up = "upR",
    down = "downR",

    a = "leftL",
    d = "rightL",
    w = "upL",
    s = "downL",

    ["return"] = "confirm",
    escape = "cancel"
}
------------------------ 'g' variables

-- stores all images used in the game
g.img = {}
g.imagePointers = {
    desktop = "desktop.png",
    playAreaBg = "playAreaBg.png",
    playAreaWindow = "playAreaWindow.png",
    playAreaForeground = "playAreaForeground.png",
    progressWindow = "progressWindow.png",
    menuTask = "task.png",
    menuTaskSelected = "taskSelected.png",
    menuStart = "start.png",
    menuStartSelected = "startSelected.png",
    taskbar = "taskbar.png",
    terminal = "terminal.png",
    hitZone = "hitZone.png",
    hitZoneForeground = "hitZoneForeground.png",
    beatInnerX = "beatInnerX.png",
    beatOuterX = "beatOuterX.png",
    beatInnerY = "beatInnerY.png",
    beatOuterY = "beatOuterY.png",
}

g.snd = {}
g.soundPointers = {
    hitLeft = "hitLeft.ogg",
    hitRight = "hitRight.ogg",
    menuNavX = "menuNavX.ogg",
    menuNavY = "menuNavY.ogg",
    tada = "tada.mp3",
    chord = "chord.mp3"
}

g.sfxVolume = 1
g.songVolume = 0.5
------------------------ 'game' variables

game.fieldOffset = {x = 50, y = 40}

game.beats = {}



game.mapDirectory = "assets/maps/"
game.currentSong = false
game.currentMap = {}

game.approachRate = 0.35
game.niceThreshold = 0.26/2
game.perfectThreshold = 0.13/2


--- beatmap structure:
--- {
---     {
---         timestamp,
---         "U2"
---     }
--- }
game.beatmapData = {
    {
        1.00,
        "L2"
    },
    {
        1.50,
        "L1"
    },
    {
        2.00,
        "R1"
    },
    {
        2.50,
        "R2",
        4,
        .5
    },
    {
        2.50,
        "U2",
        2,
        1
    }
}

------------------------ 'menu' variables

menu.current = 1
menu.taskList = {
    start = { "exit" },
    play = { "jazzJackrabbit" },
    settings = { "song volume", "sfx volume" },
    credits = { "code", "graphics", "songs", "sfx" }
}
menu.taskOffsetX = {
    6, 77, 212, 348
}


---------------------------------------------------------------------
-------------------------CORE FUNCTIONS------------------------------

function core.playSound(audio)
    audio:stop()
    audio:setVolume(g.sfxVolume)
    audio:play()
end

function core.checkInput(key)
    local input = core.keyMaps[key] and core.keyMaps[key] or "unmapped"

    if input == "unmapped" then return end -- fuck it

    if game_state == "InGame" then

        print(input)

        local particleColor
        if string.sub(input, #input, #input) == "R" then
            particleColor = {.5,.5,1}
            core.playSound(g.snd.hitRight)
        else
            particleColor = {1,0,0}
            core.playSound(g.snd.hitLeft)
        end

        if input == "leftL" or input == "leftR" then
            particle.create({
                img = g.img.beatInnerX,
                position = {core.bumpX + game.fieldOffset.x + 150, core.bumpY + game.fieldOffset.y + 150},
                velocity = {-.35,0},
                scale = {70/g.img.beatInnerX:getWidth(), 200/g.img.beatInnerX:getHeight()},
                lifetime = .25,
                color = particleColor,
                opacity = .5
            })
        elseif input == "rightL" or input == "rightR" then
            particle.create({
                img = g.img.beatInnerX,
                position = {core.bumpX + game.fieldOffset.x + 343, core.bumpY + game.fieldOffset.y + 150},
                velocity = {.25,0},
                scale = {70/g.img.beatInnerX:getWidth(), 200/g.img.beatInnerX:getHeight()},
                lifetime = .35,
                color = particleColor,
                opacity = .5
            })
        elseif input == "upL" or input == "upR" then
            particle.create({
                img = g.img.beatInnerY,
                position = {core.bumpX + game.fieldOffset.x + 150, core.bumpY + game.fieldOffset.y + 150},
                velocity = {0,-.25},
                scale = {200/g.img.beatInnerY:getWidth(), 70/g.img.beatInnerY:getHeight()},
                lifetime = .35,
                color = particleColor,
                opacity = .5
            })
         elseif input == "downL" or input == "downR" then
            particle.create({
                img = g.img.beatInnerY,
                position = {core.bumpX + game.fieldOffset.x + 150, core.bumpY + game.fieldOffset.y + 343},
                velocity = {0,.25},
                scale = {200/g.img.beatInnerY:getWidth(), 70/g.img.beatInnerY:getHeight()},
                lifetime = .35,
                color = particleColor,
                opacity = .5
            })
        end



        local direction = string.sub(input, 1, #input - 1)
        local color = string.sub(input, #input, #input) == "L" and "red" or "blue"

        for index, inputData in pairs(game.inputList) do
            if direction == inputData[2] and color == inputData[3] then
                if math.abs(game.currentSong:tell() - inputData[1]) < game.perfectThreshold then
                    -- perfect hit
                    print("wow tetris")
                elseif math.abs(game.currentSong:tell() - inputData[1]) < game.niceThreshold then
                    print("jusit a triple,,")
                end

                if math.abs(game.currentSong:tell() - inputData[1]) < game.niceThreshold then
                    game.inputList[index] = nil
                end
            end
        end





    elseif game_state == "Menu" then
        print(input)

        if input == "leftL" or input == "leftR" then
            menu.current = menu.current - 1;
        end
        if input == "rightL" or input == "rightR" then
            menu.current = menu.current + 1;
        end

        menu.current = core.clamp(menu.current, 1, 4)

    end

end

function core.clamp(number, numberMin, numberMax)
    if number < numberMin then
        number = numberMin
    elseif number > numberMax then
        number = numberMax
    end
    return number
end

 -- NOTE: for drawing within the bounds of the game window, use game.draw()
function core.draw( drawable, x, y, r, sx, sy, ox, oy, kx, ky ) -- in place of love.graphics.draw()

    if type(drawable) == "string" then -- use lg.print to draw if string
        lg.print( drawable, x, y, r, sx, sy, ox, oy, kx, ky )
    else                               -- other drawable types use lg.draw
        -- converting the scale functionality to exact pixel measurements
        if sx then
            sx = (1 / drawable:getWidth()) * sx
        end

        if sy then
            sy = (1 / drawable:getHeight()) * sy
        end

        if ox then
            if ox == "left" then
                ox = 0
            elseif ox == "center" then
                ox = drawable:getWidth()/2
            elseif ox == "right" then
                ox = drawable:getWidth()
            end
        end

        if oy then
            if oy == "top" then
                oy = 0
            elseif oy == "center" then
                oy = drawable:getHeight()/2
            elseif oy == "bottom" then
                oy = drawable:getHeight()
            end
        end

        lg.draw( drawable, x, y, r, sx, sy, ox, oy, kx, ky )
    end

end


-- returns the aspect ratio of either a drawable or X and Y size
function core.aspectRatio(firstVal, secondVal)
    if secondVal then
        return (firstVal/secondVal)
    else
        return firstVal:getWidth()/firstVal:getHeight()
    end
end

function core.update(dt)

end


---------------------------------------------------------------------
-----------------------GLOBAL FUNCTIONS------------------------------

function g.render() -- the initial rendering function. handles rendering the desktop (and responsible for zoom)

    -- determine the window size
    core.sWidth, core.sHeight = lg.getDimensions()

    -- determine the "bump" values
    core.bumpX = (core.sWidth-800)/2
    core.bumpY = (core.sHeight-600)/2





    -------------------------------------screen zoom-----------------------------------
        local ratio
        if core.sWidth > core.sHeight then
            ratio = (core.sHeight/600)
        else
            ratio = (core.sWidth/800)
        end
        local wr = (ratio)-1
        local translateX = -(core.sWidth/(1/wr)/2)
        local translateY = -(core.sHeight/(1/wr)/2)

        lg.translate(translateX, translateY)
        lg.scale(ratio,ratio)
   ------------------------------------------------------------------------------------

    -- render desktop background
    lg.push()
    lg.setColor(1,1,1)
    core.draw(g.img.desktop,
            core.sWidth/2, core.sHeight/2,
            0,
            core.sHeight*core.aspectRatio(g.img.desktop), core.sHeight,
            "center", "center")


    -- render the taskbar
    core.draw(g.img.taskbar,
            0, core.bumpY + 600,
            0,
            core.sWidth,
            36,
            "left", "bottom"
    )

    ------------------------------------------------------------------------------------

    -- render the start bar on taskbar
    game.draw(g.img.menuStart,
            6, 582,
            0,
            65,
            20,
            "left", "center"
    )

    -- render tasks
    for i = 1, 3 do
        game.draw(g.img.menuTask,
                menu.taskOffsetX[i + 1], 582,
                0,
                130,
                20,
                "left", "center"
        )
    end


    lg.pop()
end



function g.loadSkin(skinName) -- loads a skin into memory
    for name, imagePath in pairs(g.imagePointers) do
        g.img[name] = lg.newImage("assets/skins/" .. skinName .. "/" .. imagePath)
    end

    for name, audioPath in pairs(g.soundPointers) do
        g.snd[name] = love.audio.newSource("assets/skins/" .. skinName .. "/sfx/" .. audioPath, "static")
    end
end




---------------------------------------------------------------------
-----------------------GAME FUNCTIONS--------------------------------

-- NOTE: for drawing outside the bounds of the game window, use core.draw()
function game.draw( drawable, x, y, r, sx, sy, ox, oy, kx, ky ) -- in place of love.graphics.draw()
    x = x and x or 0 -- set x to 0 if it doesn't exist
    y = y and y or 0 -- set y to 0 if it doesn't exist
    core.draw( drawable, x + core.bumpX, y + core.bumpY, r, sx, sy, ox, oy, kx, ky )
end

function game.init()
    game.loadMap()
    game.currentSong:setVolume(g.songVolume)
    game.currentSong:setPitch(100/120)
    game.currentSong:play()
    game.inputList = {}
end


-- creates a beat and adds it to the beat table
function game.createBeat(startTime, endTime, direction, color, position, iterations, frequency, opacity)
    table.insert(game.beats, {
        currentTime = startTime,
        opacity = opacity,
        startTime = startTime,
        endTime = endTime,
        direction = direction,
        color = color,
        position = position,
        iterations = iterations,
        frequency = frequency
    })

    table.insert(game.inputList,{
        endTime,
        direction,
        color
    })

end

-- function called to process and increase beat step
function game.processBeats(dt)
    for index, beat in pairs(game.beats) do
        beat.currentTime = beat.currentTime + dt
        if beat.currentTime >= beat.endTime then
            if beat.iterations > 0 then
                local difference = beat.currentTime - beat.endTime
                beat.position = "inner"

                local swaps = {
                    right = "left",
                    left = "right",
                    up = "down",
                    down = "up"
                }

                print(beat.endTime + beat.frequency)

                game.createBeat(
                        beat.endTime,
                        beat.endTime + beat.frequency,
                        swaps[beat.direction],
                        beat.color,
                        "inner",
                        beat.iterations - 1,
                        beat.frequency,
                        beat.opacity
                )
            end

            game.beats[index] = nil
        end
    end

    for index, inputData in pairs(game.inputList) do
        if game.currentSong:tell() > (inputData[1] + game.niceThreshold) then
            game.inputList[index] = nil
            print("miss")
        end
    end


end

-- function called to render all current beats to the screen
function game.renderBeats()

    for _, beat in pairs(game.beats) do

        beat.opacity = beat.opacity and beat.opacity or 1

        lg.push()
        if beat.color == "red" then
            lg.setColor(1,0,0, beat.opacity)
        else
            lg.setColor(0,0,1, beat.opacity)
        end

        local ratio = (beat.currentTime - beat.startTime) / (beat.endTime - beat.startTime)
        local inverseRatio = 1 - ratio
        local xPos, yPos, ySize, xSize, rot = 0

        if beat.position == "outer" or not beat.position then


            --- CASE: IT IS LEFT
            if beat.direction == "left" then
                xPos = game.fieldOffset.x + (150 * ratio)
                yPos = game.fieldOffset.y + 250
                ySize = (300 * inverseRatio) + 200
                xSize = ySize * core.aspectRatio(g.img.beatOuterX)
            elseif beat.direction == "right" then
                xPos = game.fieldOffset.x + 500 - (150 * ratio)
                yPos = game.fieldOffset.y + 250
                ySize = -((300 * inverseRatio) + 200)
                xSize = ySize * core.aspectRatio(g.img.beatOuterX)
            elseif beat.direction == "up" then
                yPos = game.fieldOffset.y + (150 * ratio)
                xPos = game.fieldOffset.x + 250
                xSize = (300 * inverseRatio) + 200
                ySize = xSize * core.aspectRatio(g.img.beatOuterY)
            elseif beat.direction == "down" then
                yPos = game.fieldOffset.y + 500 - (150 * ratio)
                xPos = game.fieldOffset.x + 250
                xSize = -((300 * inverseRatio) + 200)
                ySize = xSize * core.aspectRatio(g.img.beatOuterY)
            end

            if beat.direction == "left" or beat.direction == "right" then
                game.draw(g.img.beatOuterX,
                        xPos, yPos,
                        rot,
                        xSize, ySize,
                        "left",
                        "center"
                )
            else
                game.draw(g.img.beatOuterY,
                        xPos, yPos,
                        rot,
                        xSize, ySize,
                        "center",
                        "top"
                )
            end
        elseif beat.position == "inner" then
            if beat.direction == "left" then
                xPos = game.fieldOffset.x + 150 + 200 - (200 * ratio)
                yPos = game.fieldOffset.y + 150
                ySize = 200
                xSize = 100



            elseif beat.direction == "right" then
                xPos = game.fieldOffset.x + 150 + (200 * ratio)
                yPos = game.fieldOffset.y + 150
                ySize = 200
                xSize = -100
            elseif beat.direction == "up" then
                yPos = game.fieldOffset.y + 150 + 200 - (200 * ratio)
                xPos = game.fieldOffset.x + 150
                ySize = 100
                xSize = 200
            elseif beat.direction == "down" then
                yPos = game.fieldOffset.y + 150 + (200 * ratio)
                xPos = game.fieldOffset.x + 150
                ySize = -100
                xSize = 200
            end


            if beat.direction == "left" or beat.direction == "right" then
                game.draw(g.img.beatInnerX,
                        xPos, yPos,
                        rot,
                        xSize, ySize,
                        "left",
                        "top"
                )
            else
                game.draw(g.img.beatInnerY,
                        xPos, yPos,
                        rot,
                        xSize, ySize,
                        "left",
                        "top"
                )
            end
        end
            lg.pop()
    end

    lg.push()
    lg.setColor(1,1,1)
    lg.pop()
end

function game.loadMap(mapName)
    game.currentMap = {
        -- MAP DATA
    }

    game.currentSong = love.audio.newSource(game.mapDirectory .. "testMap/song.mp3", "stream")
end


function game.render() -- this renders the game items (ex. play field, score, etc)
    lg.push()
    game.draw(g.img.playAreaWindow,
            game.fieldOffset.x - 6, game.fieldOffset.y - 18,
            0,
            512, 524
    )




    -- draw the play area BG
    game.draw(g.img.playAreaBg,
            game.fieldOffset.x, game.fieldOffset.y,
            0,
            500, 500
    )
    lg.pop()


    -- render beats here

    game.renderBeats()


    -- draw the play area foreground
    game.draw(g.img.playAreaForeground,
            game.fieldOffset.x, game.fieldOffset.y,
            0,
            500, 500
    )



    -- draw the center hit box
    --[[game.draw(g.img.hitZone,
            game.fieldOffset.x + 250, game.fieldOffset.y + 250,
            0,
            200, 200,
            "center", "center"
    )]]

    particle.draw()

    lg.push()
    lg.setColor(1,1,1)
    lg.pop()

    -- draw the hit zone foreground
    game.draw(g.img.hitZoneForeground,
            game.fieldOffset.x + 250, game.fieldOffset.y + 250,
            0,
            210, 210,
            "center", "center"
    )
    ---------------- render other windows
    -- draw the player status window
    game.draw(g.img.terminal,
            game.fieldOffset.x + 530, game.fieldOffset.y - 18,
            0,
            180, 320
    )



    -- draw the progress window
    game.draw(g.img.progressWindow,
            game.fieldOffset.x + 530, game.fieldOffset.y + 325,
            0,
            180, 100
    )
end

function game.update(dt)
    game.processBeats(dt)

    if not game.currentSong then return end

    local associations = {}

    for position, beatData in pairs(game.beatmapData) do

        local direction
        local color
        local opacity = 1
        local c1 = string.sub(beatData[2], 1, 1)
        local c2 = string.sub(beatData[2], 2, 2)

        if c1 == "L" then
            direction = "left"
        elseif c1 == "R" then
            direction = "right"
        elseif c1 == "U" then
            direction = "up"
        else
            direction = "down"
        end

        if c2 == "1" then
            color = "red"
        else
            color = "blue"
        end

        if associations[c1 .. tostring(beatData[1])] == true then
            opacity = 0.5
        end

        associations[c1 .. tostring(beatData[1])] = true



        if game.currentSong:tell() >= (beatData[1] - game.approachRate) then
            game.createBeat(
                    game.currentSong:tell(),
                    beatData[1],
                    direction,
                    color,
                    "outer",
                    beatData[3] and beatData[3] or 0,
                    beatData[4],
                    opacity
            )

            game.beatmapData[position] = nil
        end
    end
end

---------------------------------------------------------------------
----------------------MENU FUNCTIONS---------------------------------

function menu.render()

    if menu.current == 1 then
        game.draw(g.img.menuStartSelected,
                menu.taskOffsetX[1], 582,
                0,
                65,
                20,
                "left", "center"
        )
        -- render contexts
        local currOffset = 0
        for _, selectedContext in pairs(menu.taskList.start) do
            game.draw(g.img.menuStart,
                    menu.taskOffsetX[1], 564 - currOffset,
                    0,
                    65,
                    20,
                    "left", "bottom"
            )
            currOffset = currOffset + 20
        end
    elseif menu.current == 2 then
        game.draw(g.img.menuTaskSelected,
                menu.taskOffsetX[2], 582,
                0,
                130,
                20,
                "left", "center"
        )
        -- render contexts
        local currOffset = 0
        for _, selectedContext in pairs(menu.taskList.play) do
            game.draw(g.img.menuTask,
                    menu.taskOffsetX[2], 564 - currOffset,
                    0,
                    130,
                    20,
                    "left", "bottom"
            )
            currOffset = currOffset + 20
        end
    elseif menu.current == 3 then
        game.draw(g.img.menuTaskSelected,
                menu.taskOffsetX[3], 582,
                0,
                130,
                20,
                "left", "center"
        )
        -- render contexts
        local currOffset = 0
        for _, selectedContext in pairs(menu.taskList.settings) do
            game.draw(g.img.menuTask,
                    menu.taskOffsetX[3], 564 - currOffset,
                    0,
                    130,
                    20,
                    "left", "bottom"
            )
            currOffset = currOffset + 20
        end
    elseif menu.current == 4 then
        game.draw(g.img.menuTaskSelected,
                menu.taskOffsetX[4], 582,
                0,
                130,
                20,
                "left", "center"
        )
        -- render contexts
        local currOffset = 0
        for _, selectedContext in pairs(menu.taskList.credits) do
            game.draw(g.img.menuTask,
                    menu.taskOffsetX[4], 564 - currOffset,
                    0,
                    130,
                    20,
                    "left", "bottom"
            )
            currOffset = currOffset + 20
        end
    end

end

function menu.update(dt)

end